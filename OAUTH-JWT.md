## 구현
API 서버 형태로 구현을 진행
- 인증 :카카오/구글 소셜 로그인(코드방식) 후 jwt 발급
- 인가 : JWT를 통한 경로별 접근 권한
- 인증 정보 DB 저장 후 추가 정보 기입

### 버전 및 의존성
- Spring boot 3.2.2
- Spring Security 6.2.2
- OAuth2 Client
- LomBok
- Spring Data JPA 
- JJWT 0.12.3

### OAuth2 Code Grant 방식의 동작 순서

1. 로그인 페이지
2. 성공 후 코드 발급 (redirect_url)
3. 코드를 통해 Access 토큰 요청
4. Access 토큰 발급 완료
5. Access 토큰을 통해 유저 정보 요청
6. 유저 정보 획득 완료
7. 
### JWT 방식에서 OAuth2 클라이언트 구성시 고민점

JWT 방식에서는 로그인(인증)이 성공하면 JWT 발급 문제와 웹/하이브리드/네이티브앱별 특징에 의해 OAuth2 Code Grant 방식 동작의 책임을 프론트엔드 측에 둘 것인지 백엔드 측에 둘 것인지 많은 고민을 한다.

- **로그인(인증)이 성공하면 JWT를 발급해야 하는 문제**
    - 프론트단에서 로그인 경로에 대한 하이퍼링크를 실행하면 소셜 로그인창이 등장하고 로그인 로직이 수행된다.
    - 로그인이 성공되면 JWT가 발급되는데 하이퍼링크로 실행했기 때문에 JWT를 받을 로직이 없다. (해당 부분에 대해 redirect_url 설정에 따라 많은 고민이 필요합니다.)
    - API Client(axios, fetch)로 요청 보내면 백엔드측으로 요청이 전송되지만 외부 서비스 로그인 페이지를 확인할 수 없다.

- **웹/하이브리드/네이티브앱별 특징**
    - 웹에서 편하게 사용할 수 있는 웹페이지가 앱에서는 웹뷰로 보이기 때문에 UX적으로 안좋은 경험을 가질 수 있다.
    - 앱 환경에서 쿠키 소멸 현상

## 프론트/백 책임 분배
1. 모든 책임을 프론트가 맡음
> 프론트단에서 (로그인 → 코드 발급 → Access 토큰 → 유저 정보 획득) 과정을 모두 수행한 뒤 백엔드단에서 (유저 정보 → JWT 발급) 방식으로 주로 네이티브앱에서 사용하는 방식.
→ 프론트에서 보낸 유저 정보의 진위 여부를 따지기 위해 추가적인 보안 로직이 필요하다.

2. 책임을 프론트와 백엔드가 나누어 가짐 : 잘못된 방식
> 프론트단에서 (로그인 → 코드 발급) 후 코드를 백엔드로 전송 백엔드단에서 (코드 → 토큰 발급 → 유저 정보 획득 → JWT 발급)

3. 모든 책임을 백엔드에서 구현
> 프론트단에서 백엔드의 OAuth2 로그인 경로로 하이퍼링킹을 진행 후 백엔드단에서 (로그인 페이지 요청 → 코드 발급 → Access 토큰 → 유저 정보 획득 → JWT 발급) 방식으로 주로 웹앱/모바일앱 통합 환경 서버에서 사용하는 방식.

→ 백엔드에서 JWT를 발급하는 방식의 고민과 프론트측에서 받는 로직을 처리해야 한다.



### 카카오 dev 톡에 적혀 있는 프론트/백 책임 분배

구글링을 통해 카카오 dev 톡에 적혀 있는 프론트와 백엔드가 책임을 나눠 가지는 질문에 대한 카카오 공식 답변
![Oauth2.png](screenshots%2FOauth2.png)
앱에 대해서는 모든 책임을 프론트가 일임하고 코드나 Access 토큰을 전달하는 행위 자체를 지양

추가적으로 다른 자료들에도 코드나 Access 토큰을 전달하는 행위를 금지하고 있음